<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes"/>
<title>C7 - Solution-24航C | pansis.io</title>
<link rel="shortcut icon" href="https://github.pansis.site/favicon.ico">
<link href="https://github.pansis.site/styles/main.css" rel="stylesheet">
<link href="//at.alicdn.com/t/c/font_1678829_b85ccgkdqkr.css" rel="stylesheet">
<link href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet">
<link rel="alternate" type="application/rss+xml" title="pansis.io » Feed" href="https://github.pansis.site/atom.xml">
        <meta name="description" content="A C909



难度
考点




1
二维字符数组



题目分析
将一行英文存入二维数组中的某一行，共 121212 行，然后循环输出即可。
示例代码
#include &lt;stdio.h&gt;

char s[20][200..." />
        <meta name="keywords" content="24航C" />
        <!-- OG -->
        <meta property="og:locale" content="zh_CN">
        <meta property="og:title" content="C7 - Solution-24航C" />
        <meta property="og:type" content="article" />
        <meta property="og:description" content="A C909



难度
考点




1
二维字符数组



题目分析
将一行英文存入二维数组中的某一行，共 121212 行，然后循环输出即可。
示例代码
#include &amp;lt;stdio.h&amp;gt;

char s[20][200...">
        <meta property="og:url" content="https://github.pansis.site/post/C7 - Solution-24航C/" />
        <meta property="og:site_name" content="pansis.io">
        <meta property="og:updated_time" content="2024-11-18">
        <meta property="og:image" content="" />
        <meta property="og:image:secure_url" content="">
        <meta property="og:image:alt" content="C7 - Solution-24航C">
        <!-- Twitter (post.ejs) -->
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="C7 - Solution-24航C">
        <meta name="twitter:description" content="A C909



难度
考点




1
二维字符数组



题目分析
将一行英文存入二维数组中的某一行，共 121212 行，然后循环输出即可。
示例代码
#include &amp;lt;stdio.h&amp;gt;

char s[20][200...">
        <!-- <meta name="twitter:site" content="@WBoy0609">
        <meta name="twitter:creator" content="@WBoy0609"> -->
        <meta name="twitter:image" content="">
</head>

<body>
    <div class="main animated">
        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <a href="https://github.pansis.site">pansis.io</a>
        </div>
    </div>
    <div class="my_socials">
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
        <a href="https://github.pansis.site/atom.xml" title="rss" target="_blank"><i class="iconfont icon-rss"></i></a>
    </div>
</div>

    <div class="header_menu">
        
            
                <a href="/" class="menu">首页</a>
            
        
            
                <a href="/tag/GWAaV2nvk/" class="menu">程序设计课程</a>
            
        
            
                <a href="/tag/24hangc" class="menu">比赛</a>
            
        
            
                <a href="/tag/L7r9STb75/" class="menu">Python教程</a>
            
        
            
                <a href="/tags" class="menu">分类</a>
            
        
        <div class="gridea-search-div">
            <form id="gridea-search-form" action="https://github.pansis.site/search/">
                <input class="gridea-search-input" autocomplete="off" spellcheck="false" name="q"/>
            </form>
        </div>
    </div>

            <div class="autopagerize_page_element">
                <div class="content">
                    <div class="post_page">
                        <div class="post animated fadeInDown">
                            <div class="post_title post_detail_title">
                                <h2>
                                    C7 - Solution-24航C
                                </h2>
                                <span class="article-info">
                                    2024-11-18, 4569 words, 23 min read
                                </span>
                            </div>
                            <div class="post_content markdown">
                                <p class="md_block">
                                    <span class="md_line md_line_start md_line_end">
                                        <h2 id="a-c909"><code>A</code> C909</h2>
<table>
<thead>
<tr>
<th>难度</th>
<th>考点</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>二维字符数组</td>
</tr>
</tbody>
</table>
<h3 id="题目分析">题目分析</h3>
<p>将一行英文存入二维数组中的某一行，共 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span> 行，然后循环输出即可。</p>
<h3 id="示例代码">示例代码</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

char s[20][200]={
&quot;The country's first home-developed regional passenger jet, the ARJ21,\n&quot;,
&quot;has added a new branding name C909,\n&quot;,
&quot;Shanghai-based Commercial Aircraft Corp of China said on\n&quot;,
&quot;Tuesday during the 15th China International Aviation\n&quot;,
&quot;and Aerospace Exhibition,\n&quot;,
&quot;also known as the Zhuhai Airshow, in Zhuhai, Guangdong province.\n&quot;,
&quot;A total of 150 C909 jets have been delivered to different carriers\n&quot;,
&quot;since its commercial launch in 2016 and safely carried over 17 million passenger trips.\n&quot;,
&quot;The aircraft manufacturer COMAC said\n&quot;,
&quot;it has continued to enhance the performance,\n&quot;,
&quot;crew operation experience,\n&quot;,
&quot;and cabin comfort of the C909 aircraft.\n&quot;};

int main(){
    int l,r;
    scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
    for(int i=l;i&lt;=r;i++){
        printf(&quot;%s&quot;,s[i-1]);
    }
    return 0;
}
</code></pre>
<h2 id="b-小宇的字符查找"><code>B</code> 小宇的字符查找</h2>
<table>
<thead>
<tr>
<th>难度</th>
<th>考点</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>字符串函数 指针</td>
</tr>
</tbody>
</table>
<h3 id="题目分析-2">题目分析</h3>
<p>这道题的难点在于输入和字符查找两部分。</p>
<ul>
<li>输入问题</li>
</ul>
<p>首先需要输入一个字符串，由于输入的字符串包含空格，因此需要使用 <code>gets()</code> 而非 <code>scanf()</code> （前者遇到回车停止，后者遇到空格或回车停止）。</p>
<p>接下来涉及到不定组输入，因此需要使用 <code>while(scanf(&quot;%c&quot;,&amp;a)!=EOF)</code> ，需要注意的是每一行除了字符 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 以外，还有回车。需要在循环内部用 <code>getchar()</code> 读取掉，否则在下次循环中 <code>while(scanf(&quot;%c&quot;,&amp;a)!=EOF)</code> 读取的是回车而非下一行的字符 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>。</p>
<ul>
<li>字符查找</li>
</ul>
<p>字符查找有两种方式，一种是用字符串查找函数 <code>strchr()</code> 和 <code>strrchr()</code> 查找第一次和最后一次出现的字符，另一种是用两个循环去分别查找第一次和最后一次出现的字符。这两种方法分别对应示例代码1和示例代码2。</p>
<p>需要注意的是，<code>strchr(s,c)</code> 和 <code>strrchr(s,c)</code> 返回的是字符 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 中第一次或最后一次出现的位置的指针，并不是题目所要求的的数组下标，需要对返回值减掉数组第0个元素的指针（即 <code>s</code>）后方可得到数组下标。</p>
<h3 id="示例代码-1">示例代码 - 1</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char s[1005];
    gets(s);
    char c;
    while (scanf(&quot;%c&quot;, &amp;c) != EOF) {
        getchar();
        if (strchr(s, c) != NULL) {
            int first = strchr(s, c) - s;
            int last = strrchr(s, c) - s;
            printf(&quot;%d %d\n&quot;, first, last);
        } else {
            printf(&quot;-1\n&quot;);
        }
    }
}
</code></pre>
<h3 id="示例代码-2">示例代码 - 2</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char s[1010];
    gets(s);
    int len = strlen(s);
    char a;
    while (scanf(&quot;%c&quot;, &amp;a) != EOF) {
        int flag = 0;
        for (int i = 0; i &lt; len; i++)//从前往后找第一个出现的
        {
            if (a == s[i]) {
                flag = 1;//找到了
                printf(&quot;%d &quot;, i);
                break;
            }
        }
        for (int j = len - 1; j &gt;= 0; j--)//从后往前找最后一个出现的
        {
            if (a == s[j]) {
                flag = 1;//找到了
                printf(&quot;%d\n&quot;, j);
                break;
            }
        }
        if (flag == 0)//如果没有找到
        {
            printf(&quot;-1\n&quot;);

        }
        getchar();
    }
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="1"><a href="http://yh.pansis.site:8181"><img src="https://img.shields.io/badge/Author-pyh-blue?logo=GitHub" alt="" loading="lazy"></a></figure>
<h2 id="c-翻转加密"><code>C</code> 翻转加密</h2>
<table>
<thead>
<tr>
<th>难度</th>
<th>考点</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>字符串</td>
</tr>
</tbody>
</table>
<h3 id="题目分析-3">题目分析</h3>
<p>对于翻转的操作，我们可以用之前学过的方式交换 <code>s[a]</code> 和 <code>s[b]</code> 的值，然后将 <code>a</code> 的值加一，<code>b</code> 的值减一，重复这样的交换操作，直到交换完所有字符，即完成了子串的翻转。</p>
<h3 id="示例代码-2">示例代码</h3>
<pre><code class="language-C">#include &lt;stdio.h&gt;
int main() {
    char s[105];
    int a, b;
    scanf(&quot;%s&quot;, s);
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
    while (a &lt; b) {
        char temp = s[a];
        s[a] = s[b];
        s[b] = temp;
        a++;
        b--;
    }
    printf(&quot;%s&quot;, s);
    return 0;
}
</code></pre>
<h2 id="d-帕林卓姆"><code>D</code> 帕林卓姆</h2>
<table>
<thead>
<tr>
<th>难度</th>
<th>考点</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>字符串遍历、回文</td>
</tr>
</tbody>
</table>
<h3 id="题目分析-4">题目分析</h3>
<p>如何不定组输入字符串呢？其实就是 <code>while(scanf(&quot;%s&quot;, str) != EOF)</code>，也可以写为 <code>while(gets(str) != NULL)</code>。这是因为，当 <code>scanf</code> 读取到文件或者输入末尾时，返回的是 <code>EOF</code>。<code>gets</code> 读取到文件或者输入末尾时，返回的是 <code>NULL</code>。</p>
<p>每次读取一行字符串后，使用 <code>strlen</code> 获取字符串的长度，然后我们从字符串开头和结尾开始遍历，每次比较两个字符是否相等。如果不等，我们进行标记，然后直接退出遍历即可。这是因为，只要存在一处不等字符，该字符串就不是回文串了。遍历结束后，根据标记变量的结果进行输出即可。</p>
<p>示例代码还可以做出改进，我们并不需要从 <code>0</code> 遍历到 <code>len-1</code>，遍历到字符串的一半即可。根据字符串长度的奇偶性，<code>i</code> 和 <code>len - 1 - i</code> 可能存在重叠，可能不存在，但要实现遍历一半的效果，保证 <code>i &lt; len - 1 - i</code> 即可。</p>
<h3 id="示例代码-3">示例代码</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char str[1010];

int main()
{
    while (gets(str) != NULL) {
        int len = strlen(str);
        int flag = 1;
        for (int i = 0; i &lt; len; ++i) {
            if (str[i] != str[len - 1 - i]) {
                flag = 0;
                break;
            }
        }
        if(flag == 1)puts(&quot;YES&quot;);
        else puts(&quot;NO&quot;);
        //puts(flag ? &quot;YES&quot; : &quot;NO&quot;);
    }
    return 0;
}
</code></pre>
<h2 id="e-查询cvbb-弱化版"><code>E</code> 查询CVBB 弱化版</h2>
<table>
<thead>
<tr>
<th>难度</th>
<th>考点</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>字符串</td>
</tr>
</tbody>
</table>
<h3 id="题目分析-5">题目分析</h3>
<p>按题目的要求修改并查询 <code>CVBB</code> 的个数即可。</p>
<p>查询 <code>CVBB</code> 的个数时可以用循环每个字符都比对一遍，也可以使用 <code>strstr</code> 函数。</p>
<h3 id="示例代码-1-2">示例代码 - 1</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
char s[1010];
int q;
int calc_cvbb()
{
	int ans=0;
	int n=strlen(s+1);
	for(int i=1;i&lt;=n-3;i++)
	{
		if(s[i]=='C'&amp;&amp;s[i+1]=='V'&amp;&amp;s[i+2]=='B'&amp;&amp;s[i+3]=='B') ans++;
	}
	return ans;
}
int main()
{
	scanf(&quot;%s&quot;,s+1);
	scanf(&quot;%d&quot;,&amp;q);
	for(int i=1;i&lt;=q;i++)
	{
		int x;
		char c;
		scanf(&quot;%d %c&quot;,&amp;x,&amp;c);
		s[x]=c;
		printf(&quot;%d\n&quot;,calc_cvbb());
	}
	return 0;
}
	
</code></pre>
<h3 id="示例代码-2-2">示例代码 - 2</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
char s[1010];
int q;
int calc_cvbb()
{
	char *p=s+1;
	int ans=0;
	int len=strlen(s+1);
	while(p&lt;=s+len-1&amp;&amp;((p=strstr(p,&quot;CVBB&quot;))!=NULL))
	{
		ans++;
		p++;
	}
	return ans;
}
int main()
{
	scanf(&quot;%s&quot;,s+1);
	scanf(&quot;%d&quot;,&amp;q);
	for(int i=1;i&lt;=q;i++)
	{
		int x;
		char c;
		scanf(&quot;%d %c&quot;,&amp;x,&amp;c);
		s[x]=c;
		printf(&quot;%d\n&quot;,calc_cvbb());
	}
	return 0;
}
	
</code></pre>
<h2 id="f-循环子序列"><code>F</code> 循环子序列</h2>
<table>
<thead>
<tr>
<th>难度</th>
<th>考点</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>指针，<code>strstr</code></td>
</tr>
</tbody>
</table>
<h3 id="题目分析-6">题目分析</h3>
<p>我们可以将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 复制一份接到后面，再在新的字符串上进行查找，即可查询到所有循环子序列的位置了。</p>
<h3 id="示例代码-4">示例代码</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char s0[200005];
int flag[200006];
char s1[100005];
int main() {
    scanf(&quot;%s&quot;, s0);
    scanf(&quot;%s&quot;, s1);
    int len0 = (int)strlen(s0);
    int len1 = (int)strlen(s1);
  	// 注意，strcat函数的两个参数不能是同一个字符串
    for (int i = 0; i &lt; len1; i++) { // 复制一份接到后面
        s0[i + len0] = s0[i];
    }
    char *p = s0;
    while (strstr(p, s1) != NULL) { // 查询所有s1子序列
        p = strstr(p, s1);
        for (int i = p - s0; i &lt; p - s0 + len1; i++) { // 标记子序列位置
            flag[i] = 1;
        }
        p = p + len1;
    }
    for (int i = 0; i &lt; len0; i++) {
        if (flag[i] || flag[i + len0]) {// 前半和后半部分有标记都算是循环子序列
            printf(&quot;%c&quot;, s0[i]);
        }else {
            printf(&quot;*&quot;);
        }
    }
    return 0;
}
</code></pre>
<h2 id="g-欢唱以我之名"><code>G</code> 欢唱，以我之名！</h2>
<table>
<thead>
<tr>
<th>难度</th>
<th>考点</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>字符串操作</td>
</tr>
</tbody>
</table>
<h3 id="题目分析-7">题目分析</h3>
<p>本题的操作过程大致可以分为几个步骤：</p>
<ul>
<li>判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">s_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 结尾和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 开头字符是否相同。如果相同，进行下一步，如果不相同，则结束操作；</li>
<li>计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">s_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 结尾和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 开头相同字符总数，若大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 进行下一步，否则结束操作；</li>
<li>在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">s_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 结尾分别删去若干字符。返回第一步判断。</li>
</ul>
<p>对于第三步，我们知道字符串是<strong>字符类型的数组</strong>，数组的名称可以直接作为<strong>指向首元素的指针</strong>。因此，</p>
<ul>
<li>如果想要在字符串<code>char str[]</code>中删除前<code>n</code>个字符，只需要运用指针的运算，让<code>str = str + n</code>即可。</li>
<li>如果想要在<code>char str[]</code>中删除后<code>n</code>个字符，根据字符串的特性，可以将倒数第<code>n</code>个元素赋值为<code>'\0'</code>，即<code>str[strlen(str) - n] = '\0'</code></li>
</ul>
<p>为直观起见，我们将上述的步骤包装成函数，具体见示例代码。</p>
<h3 id="示例代码-5">示例代码</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

char lastChar(char *s) { return strlen(s) ? s[strlen(s) - 1] : 0; }
int lastNum(char *s)
{
    char tmp = lastChar(s);
    int i = strlen(s), cnt = 0;
    while (i--)
    {
        if (s[i] == tmp)
        {
            cnt++;
            continue;
        }
        break;
    }
    return cnt;
}
int firstNum(char *s)
{
    int i = 1;
    while (s[i++] == s[0])
        ;
    return --i;
}

int main()
{
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    char *s1 = (char *)malloc(sizeof(char) * 1005);
    char *s2 = (char *)malloc(sizeof(char) * 1005);
    char *STATIC_S2 = s2;
    while (n--)
    {

        scanf(&quot;%s&quot;, s1);
        getchar();
        scanf(&quot;%s&quot;, s2);
        getchar();
        int s1_l = strlen(s1);
        int s2_l = strlen(s2);
        int s1_n = lastNum(s1);
        int s2_n = firstNum(s2);
        while (s1_l &gt; 0 &amp;&amp; s2_l &gt; 0 &amp;&amp; lastChar(s1) == s2[0] &amp;&amp; s1_n + s2_n &gt;= 3)
        {
            s1[s1_l - s1_n] = '\0';
            s2 = s2 + s2_n;
            s1_l = strlen(s1);
            s2_l = strlen(s2);
            s1_n = lastNum(s1);
            s2_n = firstNum(s2);
        }
        if (s1_l == 0 &amp;&amp; s2_l == 0)
        {
            printf(&quot;clear!\n&quot;);
        }
        else if (s1_l != 0 &amp;&amp; s2_l != 0)
        {
            printf(&quot;%s%s\n&quot;, s1, s2);
        }
        else if (s1_l == 0)
        {
            printf(&quot;kori!\n&quot;);
        }
        else
            printf(&quot;miracle!\n&quot;);
        s2 = STATIC_S2;
    }
    return 0;
}
</code></pre>
<h2 id="h-五字不行"><code>H</code> 五字不行</h2>
<table>
<thead>
<tr>
<th>难度</th>
<th>考点</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>深度优先搜索，二维数组</td>
</tr>
</tbody>
</table>
<h3 id="题目分析-8">题目分析</h3>
<p>对于每次询问，假设子矩阵大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>×</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p\times q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>，我们可以考虑一个同样为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>×</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p\times q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 的空数组。从考察矩阵中的任一元素出发，将其周围所有和它相等的元素在新的空数组中标记出来，如果标记的数量大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 则停止搜索，直接输出；若否，则继续搜索未标记过的位置，并重新判断。如果一直没有超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 个标记，则输出<code>No</code></p>
<p>搜索策略：<strong>深度优先搜索 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder accentunder="true"><mi>D</mi><mo stretchy="true">‾</mo></munder><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><munder accentunder="true"><mi>F</mi><mo stretchy="true">‾</mo></munder><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><munder accentunder="true"><mi>S</mi><mo stretchy="true">‾</mo></munder><mi>e</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">\underline{D}epth \underline{F}irst \underline{S}earch</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89444em;vertical-align:-0.20000000000000007em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20000000000000007em;"><span></span></span></span></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20000000000000007em;"><span></span></span></span></span></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20000000000000007em;"><span></span></span></span></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span></span></span></span></strong></p>
<ul>
<li>从数组中一个元素开始，向四个邻接方向搜索。如果邻接元素符合<strong>要求</strong>，则将这个元素作为搜索起始元素；如果四个邻接方向都没有，则说明该元素是连续元素的边界，回溯到上一级。</li>
<li>此处的要求是：搜索的元素依然在子矩阵范围内；搜索的元素和原来的元素值相等；搜索的元素没有被搜索过。</li>
</ul>
<h3 id="示例代码-6">示例代码</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;string.h&gt;

int p = 1, map[105][105], arr[105][105], tgt;
const int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
bool check(int startx, int starty, int dx, int dy, int x, int y, int tgt);
void dfs(int startx, int starty, int dx, int dy, int x, int y);
int main()
{
    int n, m, t, x, y, a, b;
    scanf(&quot;%d %d&quot;, &amp;m, &amp;n);
    for (int i = 0; i &lt; m; i++)
    {
        for (int j = 0; j &lt; n; j++)
        {
            scanf(&quot;%d&quot;, &amp;arr[i][j]);
        }
    }
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        memset(map[0], 0, 105 * 105 * sizeof(int));
        scanf(&quot;%d %d %d %d&quot;, &amp;y, &amp;x, &amp;a, &amp;b);
        for (int i = 0; i &lt; a &amp;&amp; p &lt; 5; i++)
        {
            for (int j = 0; j &lt; b &amp;&amp; p &lt; 5; j++)
            {
                if (map[y + i][x + j] == 0)
                {
                    tgt = arr[y + i][x + j];
                    map[y + i][x + j] = 1;
                    dfs(x, y, b, a, x + j, y + i);
                    if (p &gt; 4) puts(&quot;Yes&quot;);
                    else p = 1;
                }
            }
        }
        if (p &lt; 5) puts(&quot;No&quot;);
        p = 1;
    }
    return 0;
}
bool check(int startx, int starty, int dx, int dy, int x, int y, int tgt)
{
    if (x &lt; (startx + dx) &amp;&amp; x &gt;= startx &amp;&amp; y &lt; starty + dy &amp;&amp; y &gt;= starty &amp;&amp; map[y][x] != 1 &amp;&amp; arr[y][x] == tgt)
    {
        return 1;
    }
    return 0;
}
void dfs(int startx, int starty, int dx, int dy, int x, int y)
{
    for (int i = 0; i &lt; 4; i++)
    {
        if (check(startx, starty, dx, dy, x + dir[i][0], y + dir[i][1], tgt))
        {
            map[y + dir[i][1]][x + dir[i][0]] = 1;
            p += 1;
            dfs(startx, starty, dx, dy, x + dir[i][0], y + dir[i][1]);
        }
    }
    return;
}
</code></pre>
<h2 id="i-字符串与子串"><code>I</code> 字符串与子串</h2>
<table>
<thead>
<tr>
<th>难度</th>
<th>考点</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>哈希思想，二分 or 双指针，动态数组 or 前缀和</td>
</tr>
</tbody>
</table>
<h3 id="题目分析-9">题目分析</h3>
<h4 id="双指针做法的思路">双指针做法的思路</h4>
<p>我们可以用滑动窗口的思想解决这个问题。在滑动窗口类型的问题中都会有两个指针，一个用于「延伸」现有窗口的 <code>r</code> 指针，和一个用于「收缩」窗口的 <code>l</code>指针。在任意时刻，只有一个指针运动，而另一个保持静止。我们在 <code>s</code> 上滑动窗口，通过移动 <code>r</code> 指针不断扩张窗口。当窗口包含 <code>t</code> 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。然后我们可以继续移动 <code>l</code> 指针，寻找下一处。</p>
<p>对于求解 <code>l</code> <code>r</code> 区间内的各个字母的数量，我们可以维护一个动态数组，记录各个字母的数量。也可以采用类似 前缀和 的方法，设 <code>ss[i+1][j]</code> 为到字符串的第 <code>i</code> 项统计的<code>j</code> 号字母数，则 <code>ss[r+1][j]-ss[l][j]</code> 即为  <code>l</code> <code>r</code> 区间内的 <code>j</code> 号字母的数量。</p>
<p>令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mtext>len</mtext><mo>(</mo><mi>s</mi><mo>)</mo><mo separator="true">,</mo><mi>n</mi><mo>=</mo><mtext>len</mtext><mo>(</mo><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">m=\text{len}(s),n=\text{len}(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">len</span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">len</span></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span> ，这种做法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 。</p>
<h4 id="二分做法的思路">二分做法的思路</h4>
<p>我们按照前缀和的方式统计完之后，我们可以假设最短子串的起点是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个字符，我们可以发现，如果第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个字符到第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个字符的区间成立，那么到第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>2</mn><mo>⋯</mo></mrow><annotation encoding="application/x-tex">j+1,j+2\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span></span></span></span> 个字符的区间都成立。我们设一个二元函数 <code>check(i,j)</code> 表示第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个字符到第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个字符的区间是否成立，不成立为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ，成立为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 。我们不难发现这个函数具有单调性，因此可以二分查找函数由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的转折点。</p>
<p>令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mtext>len</mtext><mo>(</mo><mi>s</mi><mo>)</mo><mo separator="true">,</mo><mi>n</mi><mo>=</mo><mtext>len</mtext><mo>(</mo><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">m=\text{len}(s),n=\text{len}(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">len</span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">len</span></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span> ，这种做法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m\log{m} + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 。</p>
<h3 id="示例代码-1-双指针做法结合动态数组">示例代码 - 1 （双指针做法结合动态数组）</h3>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int ss[30], tt[30];
int check() {
	for (int i = 0; i &lt;= 25; i++) {
		if (ss[i] &lt; tt[i])
			return 0;
	}
	return 1;
}
char s[100005], t[100005];
int main() {
	while (scanf(&quot;%s%s&quot;, s, t) != EOF) {
		for (int i = 0; i &lt;= 25; i++) {
			ss[i] = 0;
			tt[i] = 0;
		}//注意数据的初始化
		int lent = strlen(t);
		int lens = strlen(s);
		for (int i = 0; i &lt;= lent - 1; i++) {
			tt[t[i] - 'a']++;
		}
		int l = 0, r = 0, ansl = 0, ansr = 100000000;
		ss[s[0] - 'a']++;
		while (l &lt; lens || r &lt; lens) {
			if (check() == 0 &amp;&amp; r &lt; lens) {
				r++;
				if (r &lt; lens)ss[s[r] - 'a']++;
			} else if (check() == 1) {
				if (r - l &lt; ansr - ansl) {
					ansr = r;
					ansl = l;
				}
				l++;
				if (l &lt; lens)ss[s[l - 1] - 'a']--;
			} else {
				l++;
				if (l &lt; lens)ss[s[l - 1] - 'a']--;
			}
		}
		if (ansr == 100000000) {
			printf(&quot;000000\n&quot;);
		} else {
			s[ansr + 1] = 0;
			printf(&quot;%s\n&quot;, s + ansl);
		}
	}
	return 0;
}
</code></pre>
<h3 id="示例代码-2-双指针做法结合前缀和">示例代码 - 2 （双指针做法结合前缀和）</h3>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int ss[100005][30], tt[30];

int check(int st, int ed) {
	for (int i = 0; i &lt;= 25; i++) {
		if (ss[ed + 1][i] - ss[st][i] &lt; tt[i])
			return 0;
	}
	return 1;
}
char s[100005], t[100005];
int main() {
	while (scanf(&quot;%s%s&quot;, s, t) != EOF) {
		for (int i = 0; i &lt;= 25; i++) {
			ss[0][i] = 0;
			tt[i] = 0;
		}//注意数据的初始化
		int lent = strlen(t);
		int lens = strlen(s);
		for (int i = 0; i &lt;= lent - 1; i++) {
			tt[t[i] - 'a']++;
		}
		for (int i = 0; i &lt;= lens - 1; i++) {
			for (int j = 0; j &lt;= 25; j++) {
				ss[i + 1][j] = ss[i][j];
			}
			ss[i + 1][s[i] - 'a']++;
		}
		int l = 0, r = 0, ansl = 0, ansr = 100000000;
		while (l &lt; lens || r &lt; lens) {
			if (check(l, r) == 0 &amp;&amp; r &lt; lens) {
				r++;
			} else if (check(l, r) == 1) {
				if (r - l &lt; ansr - ansl) {
					ansr = r;
					ansl = l;
				}
				l++;
			} else {
				l++;
			}
		}
		if (ansr == 100000000) {
			printf(&quot;000000\n&quot;);
		} else {
			s[ansr + 1] = 0;
			printf(&quot;%s\n&quot;, s + ansl);
		}
	}
    return 0;
}
</code></pre>
<h3 id="示例代码-3-二分做法结合前缀和">示例代码 - 3 （二分做法结合前缀和）</h3>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int ss[100005][30], tt[30];

int check(int st, int ed) {
	for (int i = 0; i &lt;= 25; i++) {
		if (ss[ed + 1][i] - ss[st][i] &lt; tt[i])
			return 0;
	}
	return 1;
}
char s[100005], t[100005];
int main() {
	while (scanf(&quot;%s%s&quot;, s, t) != EOF) {
		for (int i = 0; i &lt;= 25; i++) {
			ss[0][i] = 0;
			tt[i] = 0;
		}//注意数据的初始化
		int lent = strlen(t);
		int lens = strlen(s);
		for (int i = 0; i &lt;= lent - 1; i++) {
			tt[t[i] - 'a']++;
		}
		for (int i = 0; i &lt;= lens - 1; i++) {
			for (int j = 0; j &lt;= 25; j++) {
				ss[i + 1][j] = ss[i][j];
			}
			ss[i + 1][s[i] - 'a']++;
		}
		int ansl, ansr, anslen = 100000000;//anslen定义一个很大的非法值
		for (int mid = 0; mid &lt;= lens - 1; mid++) {
			int nl = mid, nr = lens - 1;
			while (nr - nl &gt; 1) {
				int nmid = (nr + nl) / 2;
				if (check(mid, nmid)) {
					nr = nmid;
					if (anslen &gt; nmid - mid + 1) {
						anslen = nmid - mid + 1;
						ansl = mid;
						ansr = nmid;
					}
				} else {
					nl = nmid;
				}
			}
			if (check(mid, nr)) {
				if (anslen &gt; nr - mid + 1) {
					anslen = nr - mid + 1;
					ansl = mid;
					ansr = nr;
				}
			}
			if (check(mid, nl)) {
				if (anslen &gt; nl - mid + 1) {
					anslen = nl - mid + 1;
					ansl = mid;
					ansr = nl;
				}
			}
		}
		if (anslen != 100000000) {
			*(s + ansr + 1) = 0;
			printf(&quot;%s\n&quot;, s + ansl);
		} else {
			printf(&quot;000000\n&quot;);
		}
	}
    return 0;
}
</code></pre>
<h2 id="j-int-2-long-long仅供参考"><code>J</code> int 2 long long（仅供参考）</h2>
<table>
<thead>
<tr>
<th>难度</th>
<th>考点</th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>字符串、C语言语法/编译器模拟</td>
</tr>
</tbody>
</table>
<h3 id="题目分析-10">题目分析</h3>
<p>按照语法规则，排除掉字符串、变量名、函数名、注释，再进行替换即可。</p>
<p>字符串是放在两个英文双引号里的片段；</p>
<p>排除掉字符串，如果字符串 <code>int</code> 两边出现了 数字、其他字母、下划线，则是变量名/函数名。</p>
<p>如果是在某行的字符 <code>//</code> 后面，或者在<code>/**/</code> 里面，则为注释。</p>
<p>其他的为关键字。（可能有考虑不全的情况，欢迎提出）</p>
<h3 id="参考代码">参考代码</h3>
<p>本代码未必考虑了所有情况，仅考虑了 <code>int</code> 这三个字符在字符串、变量名、函数名、注释中的出现情况。</p>
<p>如果你找到了更多的情况（能使这份代码出现bug，且编译器没有报出警告），欢迎联系助教。</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;ctype.h&gt;
#include&lt;stdlib.h&gt;
char a[1010];
int check(int c) {
	if (c &lt; 0)return 0;
	if (isdigit(a[c]))return 1;
	if (a[c] == '_')return 1;
	if (isalpha(a[c]))return 1;
	return 0;
}
int main() {
	int sgn = 0;
	while (gets(a) != NULL) {
		int len = strlen(a);
		for (int i = 0; i &lt;= len - 1; i++) {
			if (sgn == 4) {
				if (a[i] == '*' &amp;&amp; a[i + 1] == '/') {
					sgn = 0;
				}
			}
			if (a[i] == '\&quot;' &amp;&amp; (i == 0 || a[i - 1] != '\\')) {
				if (sgn == 0) {
					sgn = 1;
				} else if (sgn == 1) {
					sgn = 0;
				}
			}
			if (a[i] == '\'' &amp;&amp; (i == 0 || a[i - 1] != '\\')) {
				if (sgn == 0) {
					sgn = 2;
				} else if (sgn == 2) {
					sgn = 0;
				}
			}
			if (sgn == 0) {
				if (a[i] == '/' &amp;&amp; a[i + 1] == '/') {
					sgn = 3;
				}
				if (a[i] == '/' &amp;&amp; a[i + 1] == '*') {
					sgn = 4;
				}
				if (a[i] == '#') {
					sgn = 3;
				}
				if (a[i] == 'i' &amp;&amp; a[i + 1] == 'n' &amp;&amp; a[i + 2] == 't') {
					if (check(i - 1) || check(i + 3)) {
						;
					} else {
						printf(&quot;long long&quot;);
						i += 2;
						continue;
					}
				}
			}
			printf(&quot;%c&quot;, a[i]);
		}
		printf(&quot;\n&quot;);
		if (sgn == 3 &amp;&amp; a[len - 1] != '\\')sgn = 0;
		memset(a, 0, sizeof(a));
	}
	return 0;
}
</code></pre>
<br />
                                            
                                </p>
                            </div>
                            <div class="post_footer">
                                
                                    <div class="meta">
                                        <div class="info"><span class="field tags"><i class="iconfont icon-tag-sm"></i>
                                                
                                                    <a href="https://github.pansis.site/tag/24hangc/" class="article-info">
                                                        24航C
                                                    </a>
                                                    
                                            </span>
                                        </div>
                                    </div>
                                    
                                        
                                            <div class="next-post" style="margin-top: 20px;">
                                                <div class="next">下一篇</div>
                                                <a href="https://github.pansis.site/post/C6 - Solution-24航c/">
                                                    <h3 class="post-title">
                                                        C6 - Solution-24航c
                                                    </h3>
                                                </a>
                                            </div>
                                            
                            </div>
                        </div>
                        
                            
                                <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<div id="gitalk-container" style="padding-bottom: 20px;"></div>
<script>
    var pageId = (location.pathname).substring(1, 49) // Ensure uniqueness and length less than 50
    pageId = pageId.endsWith('/') ? pageId.slice(0, -1) : pageId // 以斜杠结尾则去除
    var gitalk = new Gitalk({
        clientID: '9d5eba33618472c44a07',
        clientSecret: '065a85ed04333ceebfc4f01d7ca1674175730339',
        repo: 'fzxl2003.github.io',
        owner: 'fzxl2003',
        admin: ['fzxl2003'],
        id: pageId,
        distractionFreeMode: false  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>
                                    
                                        
                                                    
                    </div>
                </div>
            </div>
    </div>
    <div class="footer">
    
    <div class="powered_by">
        <a href="https://codeberg.org/kytrun/gridea-theme-one" target="_blank">Theme One,</a>
        <a href="https://open.gridea.dev/" target="_blank">Powered by Gridea&#65281;</a>
    </div>
    
    
        <div class="footer_slogan">
            Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
        </div>
    
    <div id="back_to_top" class="back_to_top">
        <span>△</span>
    </div>
    
</div>

<script src="https://github.pansis.site/media/scripts/util.js"></script>
        <link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.5.1/styles/default.min.css">
        <script src="//unpkg.com/@highlightjs/cdn-assets@11.5.1/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>
</body>

</html>